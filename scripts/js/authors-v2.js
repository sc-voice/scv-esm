#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const { logger } = require("log-instance");

const APP_DIR = path.join(__dirname, "..", "..");
const LOCAL_DIR = path.join(APP_DIR, "local");
const SRC_DIR = path.join(APP_DIR, "src");
const EBT_DATA_DIR = path.join(LOCAL_DIR, "ebt-data");
const EBT_AUTHOR = path.join(EBT_DATA_DIR, "_author.json");
const EBT_PUBV2 = path.join(EBT_DATA_DIR, "_publication-v2.json");
const SCRIPT = path.basename(__filename);
const AUTHORS_PATH = path.join(SRC_DIR, "auto", "authors-v2.mjs");
const { Examples } = require(path.join(APP_DIR, 'index.js'));

const COMMENT = [`Auto-generated by ${SCRIPT}`];

logger.logLevel = "info";

async function fileExists(fpath='') {
  const msg = "authors-v2.fileExists() ";
  try {
    await fs.promises.access(fpath);
    return true;
  } catch(e) {
    //console.log(msg, fpath, e);
    return false;
  }
}

(async function authors() {
  const msg = "authors() ";
  try {
    let langs = await fs.promises.readdir(path.join(EBT_DATA_DIR, 'translation'));
    let authorLangs = {};
    for (let i=0; i < langs.length; i++) {
      let lang = langs[i];
      let langPath = path.join(EBT_DATA_DIR, 'translation', lang);
      let authors = await fs.promises.readdir(langPath);
      for (let j=0; j < authors.length; j++) {
        let author = authors[j];
        authorLangs[author] = authorLangs[author]
          ? [lang, ...authorLangs[author]]
          : [lang];
      }
    }
    let ebtPubs = JSON.parse(await fs.promises.readFile(EBT_PUBV2));
    let pubAuthors = {};
    for (let i=0; i < ebtPubs.length; i++) {
      let v = ebtPubs[i];
      let { source_url, creator_uid, creator_name } = v;
      let src = source_url.split('/').slice(7,11);
      let [ type, lang, author, category ] = src;
      let exampleVersion = 0;
      let name = creator_name instanceof Array
        ? creator_name 
        : [ creator_name.toString() ];
      let key = `${lang}:${author}`;
      let info = pubAuthors[key] = pubAuthors[key] || {
        type,
        lang, 
        author, 
        name,
        exampleVersion,
      };
      category = category || 'sutta';
      let categoryPath = path.join(EBT_DATA_DIR, type, lang, author, category);
      switch (category) {
        case 'sutta':
          info.sutta = await fileExists(categoryPath);
          break;
        case 'vinaya':
          info.vinaya = await fileExists(categoryPath);
          break;
      }
      name.forEach(v=>{
        if (!info.name.includes(v)) {
          info.name.push(v);
        }
      });
    }
    Object.keys(pubAuthors).forEach(key => {
      let pa = pubAuthors[key];
      let authoredExample = Examples.authors
        .filter(ea => ea.author === pa.author)[0];
      if (authoredExample) {
        pa.examples = authoredExample.category instanceof Array
          ? authoredExample.category
          : [ authoredExample.category ].sort();
        pa.exampleVersion = Number(authoredExample.version);
      } else if (pa.author === 'ms') {
        pa.exampleVersion = 999999;
        pa.sutta = true;
        pa.vinaya = true;
      }
      if (!pa.sutta && !pa.vinaya) {
        console.log(msg, `omitting ${key}`);
        delete pubAuthors[key];
      }
    });


    let authorJson = JSON.stringify(pubAuthors, null, 2) + '\n';
    let authorMjs = [
      'const AUTHORS = ' + authorJson,
      'export default AUTHORS;\n',
    ].join('\n');
    await fs.promises.writeFile(AUTHORS_PATH, authorMjs);
    logger.info(`${SCRIPT}: DONE => ${AUTHORS_PATH}`);
  } catch (e) {
    logger.warn(e);
  }
})();
